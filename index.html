<!doctype html>
<html>

<head>
  <title>xrpackage | trees</title>
  <link rel=icon type="image/png" href="favicon.png">
  <link href="index.css" rel=stylesheet>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
  <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
</head>

<body class="header-gap">
  <header class=header id=header>
    <a href="/" class="nav icon">å±±</a>
    <nav class="selector nav bar" id=selector>
      <i class="fa fa-solar-system head"></i>
      <div class=header-label id=header-label>Terrain</div>
      <i class="fa fa-chevron-down tail"></i>
      <div class=selections id=selections>
        <a href="run.html" class=selection id=run-mode>
          <i class="fa fa-play"></i>
          <div class=wrap>
            <h3>Run mode</h3>
            <p>Switch to run mode</p>
          </div>
        </a>
        <a href="edit.html" class=selection id=edit-mode>
          <i class="fa fa-pencil"></i>
          <div class=wrap>
            <h3>Edit mode</h3>
            <p>You are currently editing this world</p>
          </div>
        </a>
        <a href="browse.html" class="selection dim">
          <i class="fa fa-solar-system"></i>
          <div class=wrap>
            <h3>Browse packages</h3>
            <p>Explore the XRPackage registry</p>
          </div>
        </a>
        <a href="help.html" class=selection>
          <i class="fa fa-book"></i>
          <div class=wrap>
            <h3>Documentation</h3>
            <p>Learn how to make packages and worlds</p>
          </div>
        </a>
      </div>
    </nav>
  </header>

<script type=module>
import * as THREE from './three.module.js';
import alea from './alea.js';
import {OrbitControls} from './OrbitControls.js';
import {GLTFLoader} from './xrpackage/GLTFLoader.js';

const CHUNK_HEADER_SIZE = 2 * 4;
const NUM_SLOTS = 64 * 64;
const OBJECT_SLOT_FIELDS = 1 + 10 + 1;
const OBJECT_SLOT_SIZE = OBJECT_SLOT_FIELDS * 4;
const VEGETATION_SLOT_FIELDS = 1 + 10;
const VEGETATION_SLOT_SIZE = VEGETATION_SLOT_FIELDS * 4;
const TERRAIN_BUFFER_SIZE = 512 * 1024;
const OBJECT_BUFFER_SIZE = NUM_SLOTS * OBJECT_SLOT_SIZE;
const VEGETATION_BUFFER_SIZE = NUM_SLOTS * VEGETATION_SLOT_SIZE;
const BLOCK_BUFFER_SIZE = 16 * 128 * 16 * 4;
const LIGHT_SLOT_FIELDS = 4;
const LIGHT_SLOT_SIZE = LIGHT_SLOT_FIELDS * 4;
const LIGHT_BUFFER_SIZE = NUM_SLOTS * LIGHT_SLOT_SIZE;
const TRAILER_SLOTS = 32;
const CHUNK_TRAILER_SIZE = TRAILER_SLOTS * 4;
const CHUNK_SIZE = CHUNK_HEADER_SIZE + TERRAIN_BUFFER_SIZE + OBJECT_BUFFER_SIZE + VEGETATION_BUFFER_SIZE + BLOCK_BUFFER_SIZE + LIGHT_BUFFER_SIZE + CHUNK_TRAILER_SIZE;
import {
  NUM_CELLS,
  NUM_CELLS_OVERSCAN,
  NUM_CELLS_HEIGHT,

  NUM_CHUNKS_HEIGHT,

  NUM_RENDER_GROUPS,

  GEOMETRY_BUFFER_SIZE,

  TEXTURE_SIZE,

  DEFAULT_SEED,

  NUM_POSITIONS_CHUNK,

  PEEK_FACES,
  PEEK_FACE_INDICES,
} from './constants.js';
import murmur from './murmur.js';
import indev from './indev.js';

/* const BIOMES_SIZE = _align(NUM_CELLS_OVERSCAN * NUM_CELLS_OVERSCAN * Uint8Array.BYTES_PER_ELEMENT, Float32Array.BYTES_PER_ELEMENT);
const TEMPERATURE_SIZE = _align(1 * Uint8Array.BYTES_PER_ELEMENT, Float32Array.BYTES_PER_ELEMENT);
const HUMIDITY_SIZE = _align(1 * Uint8Array.BYTES_PER_ELEMENT, Float32Array.BYTES_PER_ELEMENT); */
const ELEVATIONS_SIZE = NUM_CELLS_OVERSCAN * NUM_CELLS_OVERSCAN * Float32Array.BYTES_PER_ELEMENT;
const ETHER_SIZE = ((NUM_CELLS + 1) * (NUM_CELLS_HEIGHT + 1) * (NUM_CELLS + 1)) * Float32Array.BYTES_PER_ELEMENT;
const WATER_SIZE  = ((NUM_CELLS + 1) * (NUM_CELLS_HEIGHT + 1) * (NUM_CELLS + 1)) * Float32Array.BYTES_PER_ELEMENT;
const LAVA_SIZE = ((NUM_CELLS + 1) * (NUM_CELLS_HEIGHT + 1) * (NUM_CELLS + 1)) * Float32Array.BYTES_PER_ELEMENT;
const POSITIONS_SIZE = NUM_POSITIONS_CHUNK * Float32Array.BYTES_PER_ELEMENT;
const INDICES_SIZE = NUM_POSITIONS_CHUNK * Uint32Array.BYTES_PER_ELEMENT;
const COLORS_SIZE = NUM_POSITIONS_CHUNK * Float32Array.BYTES_PER_ELEMENT;
const STATIC_HEIGHTFIELD_SIZE = NUM_CELLS_OVERSCAN * NUM_CELLS_OVERSCAN * Float32Array.BYTES_PER_ELEMENT;
const ATTRIBUTE_RANGES_SIZE = NUM_CHUNKS_HEIGHT * 6 * Uint32Array.BYTES_PER_ELEMENT;
const INDEX_RANGES_SIZE = NUM_CHUNKS_HEIGHT * 6 * Uint32Array.BYTES_PER_ELEMENT;
const PEEK_SIZE = 16 * Uint8Array.BYTES_PER_ELEMENT;
const PEEKS_ARRAY_SIZE = PEEK_SIZE * NUM_CHUNKS_HEIGHT;

const _requestImage = src => new Promise((accept, reject) => {
  const img = document.createElement('img');
  img.src = src;
  img.onload = () => {
    accept(img);
  };
  img.onerror = reject;
});

const rng = new alea('a');
const generator = indev({
  seed: DEFAULT_SEED,
});
const elevationNoise = generator.uniform({
  frequency: 0.002,
  octaves: 8,
});
const treeNoise = generator.uniform({
  frequency: 0.1,
  octaves: 4,
});

(async () => {

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  alpha: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
renderer.domElement.style.backgroundColor = '#000';
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 10, 20);

const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
// orbitControls.update();
// orbitControls.target.set(0, 64, 0);

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(10, 10, 10)
scene.add(directionalLight);
const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
scene.add(directionalLight2);

const {scene: trees} = await new Promise((accept, reject) => {
  new GLTFLoader().load('trees.glb', accept, function onProgress() {}, reject);
});
// console.log('got trees', trees);
// trees.position.set(0, 70, 0);
// trees.scale.set(0.1, 0.1, 0.1);
trees.children.forEach((c, i) => {
  if (/mothertree/i.test(c.name)) {
    c.visible = false;
  }
});
// trees.remove(trees.children[34]); //.scale.multiplyScalar(0.0001);
// trees.remove(trees.children[30]);
// trees.children.splice(0, 34);
const _isIsland = a => /island/i.test(a.name);
const _isTree = a => /tree/i.test(a.name);
const _isBark = a => /bark/i.test(a.name);
const _isGrass = a => /grass/i.test(a.name);
const _isFlower = a => /flower/i.test(a.name);
const _isCrystal = a => /crystal/i.test(a.name);
trees.children
  .sort((a, b) => +_isCrystal(b) - _isCrystal(a))
  .sort((a, b) => +_isFlower(b) - _isFlower(a))
  .sort((a, b) => +_isGrass(b) - _isGrass(a))
  .sort((a, b) => +_isBark(b) - _isBark(a))
  .sort((a, b) => +_isTree(b) - _isTree(a))
  .sort((a, b) => +_isIsland(b) - _isIsland(a))
for (let i = 0; i < trees.children.length; i++) {
  const o = trees.children[i];
  console.log(o.name);
  // console.log('got mesh', o);
  o.position.x += -10 + (i++) * 1;
  /* if (i >= 0) {
    o.scale.set(0.000001, 0.000001, 0.000001);
  } */
}
// trees.children.splice(8, Infinity)
const treeMaterial = new THREE.ShaderMaterial({
  uniforms: {
    tex: {
      type: 't',
      value: trees.children[0].material.map,
    },
  },
  vertexShader: `\
    varying vec3 vPosition;
    varying vec2 vUv;
    varying vec3 vNormal;

    void main() {
      vUv = uv;
      vNormal = normal;

      vPosition = position.xyz;
      vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );
      gl_Position = projectionMatrix * mvPosition;
    }
  `,
  fragmentShader: `\
    varying vec3 vPosition;
    varying vec2 vUv;
    varying vec3 vNormal;
    uniform sampler2D tex;

    void main() {
      vec3 tV = texture2D(tex, vUv).rgb;
      gl_FragColor = vec4( tV, 1.0 );
      // gl_FragColor.rgb *= 0.9 + 0.1 * dot(vNormal, normalize(vec3(1.0, 1.0, 1.0)));
      gl_FragColor.rgb *= 0.75 + pow(min(max(vPosition.y / 1000.0, 0.0), 1.0), 1.0) * 0.5;
    }
  `
});
trees.traverse(o => {
  if (o.isMesh) {
    o.material = treeMaterial;
    /* o.material = new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
      map: o.material.map,
    }); */
  }
});
console.log('got', trees, trees.children.length);
scene.add(trees);

const _generateHeightfield = (ox, oy) => {
  const points = Array(NUM_CELLS_OVERSCAN * NUM_CELLS_OVERSCAN);
  let minHeight = Infinity;
  let maxHeight = -Infinity;

  for (let dy = 0; dy < NUM_CELLS_OVERSCAN; dy++) {
    for (let dx = 0; dx < NUM_CELLS_OVERSCAN; dx++) {
      const index = dx + (dy * NUM_CELLS_OVERSCAN);

      const ax = (ox * NUM_CELLS) + dx;
      const ay = (oy * NUM_CELLS) + dy;
      const elevation = (-0.3 + Math.pow(elevationNoise.in2D(ax + 1000, ay + 1000), 0.5)) * 64;

      points[index] = elevation;
      if (elevation < minHeight) {
        minHeight = elevation;
      }
      if (elevation > maxHeight) {
        maxHeight = elevation;
      }
    }
  }

  return {
    points,
    heightRange: [
      minHeight,
      maxHeight,
    ],
  };
};

const tree = trees.children.find(o => /island4/i.test(o.name));
const treeProbability = 0.015;

for (let x = -2; x <= 2; x++) {
  for (let y = -2; y <= 2; y++) {
    const mapChunk = _generateHeightfield(x, y);
    const {points, heightRange} = mapChunk;

    for (let dy = 0; dy < NUM_CELLS_OVERSCAN; dy++) {
      for (let dx = 0; dx < NUM_CELLS_OVERSCAN; dx++) {
        const pointIndex = dx + (dy * NUM_CELLS_OVERSCAN);
        const elevation = points[pointIndex];

        if (elevation > 0) {
          const ax = (x * NUM_CELLS) + dx;
          const ay = (y * NUM_CELLS) + dy;
          const v = treeNoise.in2D(ax + 1000, ay + 1000);

          if (v < treeProbability) {
            // for (let i = 0; i < 20; i++) {
              // const tree = trees[Math.floor(rng() * trees.length)];
              const child = tree.children[Math.floor(rng() * tree.children.length)];
              const index = child.geometry.index.array[Math.floor(rng() * child.geometry.index.array.length)];
              const position = new THREE.Vector3().set(
                ax,
                elevation,
                ay
              );
              const tree2 = tree.clone();
              tree2.position.copy(position);
              scene.add(tree2);
            // }
          }
        }
      }
    }
  }
}


function animate() {
  orbitControls.update();

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

/* let currentSession = null;
function onSessionStarted(session) {
  session.addEventListener('end', onSessionEnded);

  renderer.xr.setSession(session);

  currentSession = session;
}
function onSessionEnded() {
  currentSession.removeEventListener('end', onSessionEnded);

  currentSession = null;
}
navigator.xr && navigator.xr.requestSession('immersive-vr', {
  optionalFeatures: [
    'local-floor',
    'bounded-floor',
  ],
}).then(onSessionStarted); */

})();

</script>
</body>

</html>